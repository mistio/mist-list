<link rel="import" href="../vaadin-grid/vaadin-grid.html">
<link rel="import" href="../vaadin-grid/vaadin-grid-sorter.html">
<link rel="import" href="../vaadin-grid/vaadin-grid-filter.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../paper-dialog/paper-dialog.html">
<link rel="import" href="../paper-menu-button/paper-menu-button.html">
<link rel="import" href="../vaadin-combo-box/vaadin-combo-box.html">
<link rel="import" href="../vaadin-context-menu/vaadin-context-menu.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../paper-checkbox/paper-checkbox.html">
<link rel="import" href="../paper-menu/paper-menu.html">
<link rel="import" href="../app-layout/app-layout.html">
<link rel="import" href="../paper-styles/shadow.html">

<link rel="import" href="mist-check.html">
<link rel="import" href="rest-data-provider.html">

<script src="../moment/moment.js"></script>

<dom-module id="mist-list">
    <template>
        <style>
            :host {
                display: block;
                --row-height: 64px;
            }

            [hidden] {
                display: none !important;
            }

            :host[fullscreen] {
                position: fixed;
                top: 64px;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: 99999;
                background-color: #fff;
                height: 100vh !important;
            }

            :host[resizable] {
                padding: 0;
                width: calc(85% + 119px);
                margin: auto;
                max-width: 100%;
            }

            :host[selectable] vaadin-grid {
                --vaadin-grid-cell: {
                    cursor: pointer;
                }
            }

            :host[toolbar] vaadin-grid {
                height: calc(100% - 64px);
            }

            vaadin-grid {
                font: 400 14px;
                color: #424242;
                height: 100%;
                --vaadin-grid-cell_-_padding: 8px;

                --vaadin-grid-cell: {
                    padding: 0 16px;
                    cursor: pointer;
                }

                --vaadin-grid-body-cell: {
                    height: var(--row-height);
                }


                --vaadin-grid-header-cell: {
                    background: rgba(240, 240, 240, 1);
                    min-height: 42px;
                    height: calc(var(--row-height) - 8px);
                }

                --vaadin-grid-body-row-selected-cell: {
                    background-color: rgba(255, 255, 141, 0.9) !important;
                    color: rgba(41, 41, 41, 1);
                    opacity: .8;
                }

                --vaadin-grid-body-row-odd-cell: {
                    background-color: rgb(251, 251, 251);
                }

                --vaadin-grid-body-row-hover-cell: {
                    background-color: rgb(245, 245, 245);
                    opacity: 1.0 !important;
                    color: rgba(51, 51, 51, .85);
                }

                --vaadin-grid-body-row-details-cell: {
                    text-align: center;
                }

                --vaadin-grid-column-resize-handle: {
                    opacity: 0;
                }
            }

            vaadin-grid::content div#table,
            vaadin-grid::slotted(div#table) {
                outline-width: 0px !important;
            }

            vaadin-grid::content vaadin-grid-table-cell,
            vaadin-grid::slotted(vaadin-grid-table-cell) {
                overflow: hidden;
            }

            vaadin-grid input[type=checkbox] {
                height: 16px;
                width: 16px;
            }

            vaadin-grid .image {
                height: 40px;
                width: 40px;
                display: inline-block;
                border-radius: 50%;
                vertical-align: middle;
                margin-right: 15px;
            }

            vaadin-grid .header-content {
                display: flex;
                padding: 16px;
                justify-content: space-between;
            }

            vaadin-grid .details-cell {
                background: #f0f0f0;
                width: 100%;
                font-size: 12px;
            }


            vaadin-grid .details {
                display: block;
                font-family: monospace;
                overflow-x: auto;
                overflow-y: scroll;
                height: 266px;
                margin: 0 16px;
            }

            vaadin-grid .details table {
                position: inherit;
                padding-left: 0px;
                overflow: scroll;
                border-spacing: 0px;
            }

            vaadin-grid .details table tbody {
                border-top: 1px solid #dbdbdb;
                border-bottom: 1px solid #dbdbdb;
                margin-top: 2px;
                margin-bottom: 2px;
            }

            vaadin-grid .details table tr.keys {
                display: none;
            }

            vaadin-grid .details td.key {
                font-weight: bold;
                min-width: 155px;
                border-right: 1px solid #dbdbdb;
                padding: 3px 16px 3px 30px;
                text-align: right;
                vertical-align: top;
            }

            vaadin-grid .details td.value {
                padding-left: 8px;
                white-space: pre-wrap;
                text-align: left;
                display: -webkit-box;
                max-height: 200px;
                overflow-y: auto;
                border-bottom: 1px dotted #eee;
            }

            vaadin-grid-sorter,
            span.header {
                text-transform: uppercase;
                font-size: 14px;
                font-weight: 400;
            }

            vaadin-grid-sorter {
                padding: 16px 0;
            }

            paper-input {
                display: inline-block;
                width: 100%;
            }

            mist-check::slotted(iron-icon) {
                color: #424242;
            }

            div#actions {
                background-color: #666;
                z-index: 3;
                position: fixed;
                padding: 10px 16px;
                width: calc(100% - 32px);
                height: 36px;
                margin-bottom: -56px;
                color: #fff;
                display: flex;
                top: 0;
            }

            app-toolbar {
                --paper-toolbar-background: #fff;
                border: 1px solid #dbdbdb;
                border-bottom: 0 none;
                color: #000;
            }

            app-toolbar .title {
                font-size: 18px !important;
                text-tranform: uppercase;
                font-weight: 400;
            }

            h2.titleh2 {
                line-height: 1.1em !important;
            }

            span.title {
                overflow: visible !important;
                text-transform: capitalize;
                font-weight: 600;
            }

            span.count {
                font-size: 16px;
                width: 68px;
                display: inline-block;
                text-align: center;
                opacity: .5;
                margin-right: 24px;
            }

            paper-menu-button.column-menu {
                position: absolute;
                z-index: 1;
                background-color: rgba(240, 240, 240, 0.9);
                padding: calc(var(--row-height)/2 - 25px) 0;
                margin: 1px 4px;
            }

            vaadin-grid .cell {
                padding: 0 !important;
            }

            paper-input#filterName {
                max-width: 100%;
                width: calc(100% - 48px);
            }

            paper-input#searchInput {
                margin-bottom: 16px;
                margin-left: 8px;
            }

            .nodata {
                padding: 24px;
                font-style: italic;
                text-align: center;
            }

            paper-dialog ::content #scrollable,
            paper-dialog ::slotted(#scrollable) {
                display: flex;
                flex-wrap: wrap;
                max-width: 600px;
            }

            paper-dialog p {
                width: 100%;
            }

            paper-dialog paper-item {
                width: 27%;
                min-width: 150px;
                cursor: pointer;
            }

            paper-menu paper-item {
                cursor: pointer;
            }
            paper-menu paper-item.filter {
                padding: 0;
                padding-left: 16px !important;
            }
            paper-menu paper-item.filter.all-items {
                text-transform: capitalize;
                padding-right: 16px !important;
            }
            #presetFilters {
                display: flex;
                flex-direction: row;
            }

            #presetFilters span {
                flex: 1;
            }

            paper-icon-button.clear-filter {
                opacity: .5;
                transform: scale(.7);
            }

            app-toolbar:not(.preset-filters-0) {
                padding: 0 !important;
            }

            paper-dialog#filterDialog {
                max-width: 400px;
            }

            paper-dialog#filterDialog > .buttons {
                padding: 24px;
            }
        </style>
        <template is="dom-if" restamp if="[[useDataProvider]]">
            <rest-data-provider url="[[apiurl]]" provider="{{dataProvider}}" loading="{{_loading}}" count={{count}} received={{received}}
                columns={{columns}} frozen=[[frozen]] item-map={{itemMap}} primary-field-name="[[primaryFieldName]]" timeseries=[[timeseries]]
                filter="[[combinedFilter]]" finished={{finished}}></rest-data-provider>
        </template>
        <slot name="header"></slot>
        <app-toolbar class$="preset-filters-[[combinedPresetFilters.length]]" hidden$=[[!toolbar]]>
            <paper-icon-button icon="menu" drawer-toggle on-tap="_toggleDrawer" hidden$=[[!drawer]]></paper-icon-button>
            <paper-menu-button id="presetFilters" horizontal-align="left" vertical-align="top" vertical-offset="40" hidden$="[[!combinedPresetFilters.length]]">
                <paper-icon-button icon="filter-list" slot="dropdown-trigger" class="dropdown-trigger" alt="select filter" title="Select preset filters"></paper-icon-button>
                <paper-menu slot="dropdown-content" class="dropdown-content" attr-for-selected="id" selected="{{selectedPresetFilter}}">
                    <paper-item id="" class="filter all-items" on-tap="_clearFilter"><span>[[name]]</span></paper-item>
                    <template is="dom-repeat" items="[[combinedPresetFilters]]">
                        <paper-item id$="[[item.filter]]" class="filter"><span>[[item.name]]</span>
                            <paper-icon-button class="clear-filter" icon="icons:delete" title="Delete filter" on-tap="_deletePresetFilter" hidden$="[[item.default]]"></paper-icon-button>
                        </paper-item>
                    </template>
                </paper-menu>
            </paper-menu-button>
            <iron-icon icon="search" hidden$=[[!searchable]] style="opacity: .5" on-tap=
            "_startEditingFilter"></iron-icon>
            <h2 class="titleh2" hidden$=[[editingFilter]] style="margin-left: 22px; width: 100%" on-tap="_startEditingFilter">
                <span class="count" hidden$=[[timeseries]]>
                    <template is="dom-if" if="[[!_hasReceivedAll(count)]]">[[received]]/</template>[[count]]
                </span>
                <span class="title">
                    [[_displayName(name,selectedPresetFilter,userFilter)]]
                </span>
            </h2>
            <paper-input id="searchInput" hidden$=[[!editingFilter]] on-focused-changed="_stopEditingFilter" autofocus on-keydown="_keyDown"
                value={{userFilter}}>
            </paper-input>
            <paper-icon-button icon="close" hidden$=[[!editingFilter]] on-tap="_clearFilter" id="clearFilterBtn"></paper-icon-button>
            <paper-icon-button on-tap="_openDialogSaveFilter" icon="icons:save" hidden$="[[!showSaveSearch]]">save filter</paper-icon-button>
            <span hidden$="[[!enableFullscreen]]">
                <paper-icon-button icon="icons:fullscreen" hidden$=[[fullscreen]] on-tap="_enterFullscreen" id="fullscreenBtn"></paper-icon-button>
                <paper-icon-button icon="icons:fullscreen-exit" hidden$=[[!fullscreen]] on-tap="_exitFullscreen" id="exitFullscreenBtn"></paper-icon-button>
            </span>
        </app-toolbar>

        <slot name="actions"></slot>

        <template is="dom-if" if="[[visible]]" restamp>
            <paper-dialog id="columnsDialog" with-backdrop opened={{columnsDialogOpened}}>
                <h2>Select columns</h2>
                <paper-dialog-scrollable>
                    <p>Select the list's visible columns.</p>
                    <template is="dom-if" if="[[columnsDialogOpened]]" restamp>
                        <template is="dom-repeat" items="[[columns]]" as="column">
                            <paper-item label="[[column]]">
                                <paper-checkbox checked="[[_isColumnVisible(column,visible)]]" on-change="_checkboxChanged">[[column]]</paper-checkbox>
                            </paper-item>
                        </template>
                    </template>
                </paper-dialog-scrollable>
                <div class="buttons">
                    <paper-button dialog-confirm>Close</paper-button>
                </div>
            </paper-dialog>

            <paper-dialog id="csvDialog" with-backdrop>
                <h2>Download list data in CSV</h2>
                <paper-dialog-scrollable>
                    <p>Select columns to download.</p>
                    <template is="dom-repeat" items="[[columns]]" as="column">
                        <paper-item label="[[column]]">
                            <paper-checkbox checked="[[_isCsvVisible(column)]]" on-change="_CSVcheckboxChanged">[[column]]</paper-checkbox>
                        </paper-item>
                    </template>
                </paper-dialog-scrollable>
                <div class="buttons">
                    <paper-button dialog-dismiss>Cancel</paper-button>
                    <paper-button dialog-confirm autofocus on-tap="_exportCsv">Download CSV</paper-button>
                </div>
            </paper-dialog>
        </template>

        <vaadin-grid id="grid" data-provider="[[dataProvider]]" selected-items={{selectedItems}} size=[[count]] loading$="[[_loading]]"
            on-active-item-changed="_activeItemChanged" selection-mode="multi" multi-sort=[[multiSort]]>
            <div id="actions" slot="actions" hidden$=[[!selectedItems.length]]>
                <mist-check selected="{{selectAll}}">[[selectedItems.length]]</mist-check>
                <slot name="action-buttons"></slot>
            </div>
            <paper-menu-button slot="actions" horizontal-align="left" vertical-align="top" vertical-offset="40" class="column-menu" style$="[[_computeMenuButtonStyle(selectable, expands, columnMenu, selectedItems.length, count)]]">
                <paper-icon-button icon="icons:view-column" class="dropdown-trigger" alt="multi select" title="Select columns & export CSV"></paper-icon-button>
                <paper-menu class="dropdown-content">
                    <paper-item on-tap="_openDialogSelectColumns">Select columns</paper-item>
                    <paper-item on-tap="_openDialogExportCsv" disabled$="[[!apiurl]]">Download CSV</paper-item>
                </paper-menu>
            </paper-menu-button>
            <template class="row-details">
                <div class="details-cell">
                    <div class="details" on-tap="_preventDefault" on-click="_preventDefault" on-pointerup="_preventDefault" on-mouseup="_preventDefault">
                        <table>
                            <tbody>
                                <template is="dom-repeat" items="{{_itemKeys(item)}}" as="i">
                                    <tr class$="[[i.key]]">
                                        <td class="key">[[i]]</td>
                                        <td class="value">[[_getRawBody(i, item)]]</td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>
                </div>
            </template>
            <template is="dom-if" if="[[selectable]]" restamp>
                <vaadin-grid-column width="64px" flex-grow="0" frozen on-click="_alertAndPreventDefault" style="overflow: visible; padding: 0 !important">
                    <template class="header">
                        <mist-check selected="{{selectAll}}"></mist-check>
                    </template>
                    <template>
                        <mist-check class="item-check" selected="{{selected}}" style$="margin-left: -16px; padding: 16px; [[_computeIndicatorStyle(item,renderers.indicator)]]"
                            icon="[[_computeIcon(item, renderers.icon)]]" item="[[item]]"></mist-check>
                    </template>
                </vaadin-grid-column>
            </template>
            <template is="dom-if" if="[[_or(expands, columnMenu)]]" restamp>
                <vaadin-grid-column width="[[_computeMenuCellWidth(expands)]]" flex-grow="0" frozen>
                    <template class="header">
                    </template>
                    <template>
                        <paper-icon-button icon="icons:arrow-drop-down" style$="[[_computeIconStyle(expanded)]]; margin-left: -12px;" toggles active="{{expanded}}"
                            id="btn-[[_computeId(item)]]" hidden$=[[!expands]]></paper-icon-button>
                    </template>
                </vaadin-grid-column>
            </template>
            <template is="dom-repeat" items="[[frozen]]" as="column">
                <vaadin-grid-column frozen resizable width$="[[columnWidth(column,frozenWidth)]]">
                    <template class="header" style="z-index: 1">
                        <vaadin-grid-sorter path="[[column]]" direction$=[[_getDirection(column)]] cmp="[[_getComparisonFunction(column)]]"  hidden$=[[timeseries]] id$="sorter-column-[[column]]" style="z-index: 1 !important">[[_getTitle(column)]]</vaadin-grid-sorter>
                        <span class="header" hidden$=[[!timeseries]]>[[_getTitle(column)]]</span>
                    </template>
                    <template>
                        <div inner-h-t-m-l="[[_getBody(column, item)]]"></div>
                    </template>
                </vaadin-grid-column>
            </template>

            <template is="dom-repeat" items="{{visible}}" as="column" restamp>
                <vaadin-grid-column resizable width$="[[columnWidth(column)]]">
                    <template class="header">
                        <vaadin-grid-sorter path="[[column]]" direction$=[[_getDirection(column)]]  cmp="[[_getComparisonFunction(column)]]" hidden$=[[timeseries]] id$="sorter-column-[[column]]">[[_getTitle(column)]]</vaadin-grid-sorter>
                        <span class="header" hidden$=[[!timeseries]]>[[_getTitle(column)]]</span>
                    </template>
                    <template>
                        <div style="margin-left:-16px;padding:16px;" inner-h-t-m-l="[[_getBody(column, item)]]"></div>
                    </template>
                </vaadin-grid-column>
            </template>

            <template is="dom-if" if="[[!visible.length]]" restamp>
                <template is="dom-repeat" items="[[columns]]" as="column">
                    <vaadin-grid-column resizable width$="[[columnWidth(column)]]">
                        <template class="header">
                            <vaadin-grid-sorter path="[[column]]" direction$=[[_getDirection(column)]] cmp="[[_getComparisonFunction(column)]]" hidden$=[[timeseries]] id$="sorter-column-[[column]]">[[_getTitle(column)]]</vaadin-grid-sorter>
                            <span class="header" hidden$=[[!timeseries]]>[[_getTitle(column)]]</span>
                        </template>
                        <template>
                            <div inner-h-t-m-l="[[_getBody(column, item)]]"></div>
                        </template>
                    </vaadin-grid-column>
                </template>
            </template>
        </vaadin-grid>

        <div class="nodata" hidden$="[[!showNoData]]">
            <slot name="no-items-found"></slot>
        </div>

        <iron-ajax id="getCsv" method="GET" loading="{{loadingCSV}}" on-request="_csvRequest" on-response="_csvResponse" on-error="_csvError"
            handle-as="txt"></iron-ajax>

        <a id="downloadCSV" href="data:application/octet-stream;[[CSVresponse]]" download$="[[_computeCSVname(apiurl)]]" hidden>
        Download </a>

        <paper-dialog id="filterDialog" with-backdrop>
            <h2>Save filter</h2>
            <paper-dialog-scrollable>
                <span>Optionally choose a filter name.</span>
                <paper-input id="filterName" value="{{filterName}}" label="Filter name" tabindex="1" auto-focus></paper-input>
            </paper-dialog-scrollable>
            <div class="buttons">
                <paper-button dialog-dismiss>Cancel</paper-button>
                <paper-button dialog-confirm on-tap="_saveFilter">Save filter</paper-button>
            </div>
        </paper-dialog>

    </template>
</dom-module>

<script>
    Polymer({
        is: 'mist-list',
        properties: {
            user: String,
            members: Array,
            apiurl: {
                type: String
            },

            items: {
                type: Array
            },

            filteredItems: {
                type: Array
            },

            count: {
                type: Number,
                value: 0,
                notify: true
            },

            autoHide: {
                type: Boolean,
                value: false
            },

            hidden: {
                type: Boolean,
                computed: '_computeHidden(autoHide, count, editingFilter)',
                reflectToAttribute: true
            },

            columns: {
                type: Array,
                value: function () {
                    return []
                }
            },

            colmap: {
                type: Object,
                value: function () {
                    return {}
                }
            },

            frozen: {
                type: Array,
                value: function () {
                    return []
                }
            },

            visible: {
                type: Array
            },

            CSVvisible: {
                type: Array
            },

            filterMethod: {
                type: Object,
                value: function () {
                    return {}
                }
            },

            renderers: {
                type: Object,
                value: function () {
                    return {}
                }
            },

            selectedItems: {
                type: Array,
                value: function () {
                    return []
                },
                notify: true
            },

            selectAll: {
                type: Boolean,
                value: false
            },

            primaryFieldName: {
                type: String,
                value: "id"
            },

            sortOrder: {
                type: Array,
                value: function () {
                    return [];
                }
            },

            multiSort: {
                type: Boolean,
                value: false
            },

            route: {
                type: Object,
                notify: true
            },

            expands: {
                type: Boolean,
                value: false
            },

            drawer: {
                type: Boolean,
                value: false
            },

            toolbar: {
                type: Boolean,
                value: false
            },

            columnMenu: {
                type: Boolean,
                value: false
            },

            itemMap: {
                type: Object
            },

            timeseries: {
                type: Boolean,
                value: false
            },

            selectable: {
                type: Boolean,
                value: false
            },

            resizable: {
                type: Boolean,
                value: false
            },

            searchable: {
                type: Boolean,
                value: false
            },

            editingFilter: {
                type: Boolean,
                value: false
            },

            baseFilter: {
                type: String,
                value: "",
                observer: '_baseFilterUpdated'
            },

            userFilter: {
                type: String
            },

            combinedFilter: {
                type: String,
                computed: '_computeFilter(baseFilter, userFilter)',
                notify: true
            },

            streaming: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },

            infinite: {
                type: Boolean,
                value: false
            },

            finished: {
                type: Boolean,
                value: false
            },

            frozenWidth: {
                type: Number,
                value: 200
            },
            showNoData: {
                type: Boolean,
                value: false
            },
            filteredItemsLength: {
                type: Number,
                computed: '_computeFilteredItemsLength(filteredItems)',
                notify: true
            },
            useDataProvider: {
                type: Boolean,
                computed: '_computeUseDataProvider(apiurl, rest)',
                value: false
            },
            sorters: {
                type: Array,
                value: []
            },
            enableFullscreen: {
                type: Boolean,
                value: true
            },
            fullscreen: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            presetFilters: {
                type: Array,
                value: []
            },
            userSavedFilters: {
                type: Array
            },
            combinedPresetFilters: {
                type: Array,
                value: [],
                computed: '_computeCombinedPresetFilters(presetFilters,userSavedFilters.length)'
            },
            selectedPresetFilter: {
                type: String,
                value: '',
                observer: '_selectedPresetFilterChanged'
            },
            filterName: String,
            showSaveSearch: {
                type: Boolean,
                computed: '_computeShowSaveSearch(userFilter,combinedPresetFilters.length)'
            },
            rest: {
                type: Boolean,
                value: false
            }
        },

        observers: [
            '_itemsUpdated(items)',
            '_itemMapUpdated(itemMap.*)',
            '_filterItems(items, items.length, combinedFilter, filterMethod)',
            'windowResize(filteredItems.length, route.path)',
            'selectedItemsChanged(selectedItems.length)',
            'toggleSelectAll(selectAll)',
            'setShowNoData(items, filteredItems.length)',
            '_visibleChanged(visible)',
            '_userFilterChanged(userFilter)'
        ],

        listeners: {
            'receive-log': 'eventReceived',
            'resize': 'windowResize',
            'column-resizing': 'saveColumnWidth',
            'iron-announce': '_sorterChanged',
            'keyup': 'hotkeys',
        },

        ready: function () {},

        attached: function () {
            var _this = this;
            if (this.resizable) {
                this.resizeHandler = function () {
                    _this.windowResize();
                }
                window.addEventListener("resize", this.resizeHandler);
                this.async(function () {
                    this.windowResize()
                }, 500);
            }

            if (this.infinite)
                this.listen(this.querySelector('vaadin-grid-table'), 'wheel', '_onWheel');
            try {
                if (JSON.parse(localStorage.getItem('mist-list#' + this.id))) {
                    this.set('visible', JSON.parse(localStorage.getItem('mist-list#' + this.id)));
                }

                if (localStorage.getItem('mist-list#' + this.id + '/userFilter')) {
                    this.set('userFilter', localStorage.getItem('mist-list#' + this.id + '/userFilter'));
                } else {
                    this.set('userFilter','');
                }

                if (JSON.parse(localStorage.getItem('mist-list#' + this.id + '/userSavedFilters'))) {
                    this.set('userSavedFilters', JSON.parse(localStorage.getItem('mist-list#' + this.id + '/userSavedFilters')));
                    this.fire('filter-change');
                } else {
                    this.set('userSavedFilters', [])
                }

                var sorters = JSON.parse(localStorage.getItem('mist-list#' + this.id + '/sorters'));
                if (sorters && sorters.length)
                    this.set('sorters', sorters);
            } catch(e) {
                console.warn('Failed to access localStorage: ', e);
            }

            this.fire('list-attached', {id: this.id})
        },

        detached: function () {
            if (this.resizable) {
                window.removeEventListener("resize", this.resizeHandler);
            }
        },

        _itemMapUpdated: function(itemMap) {
            if (this.itemMap && !this.rest) {
                var that = this;
                this.debounce('updateItemsList', function () {
                    console.log('itemMap updated');
                    that.$.grid.clearCache();
                    that.set('items', that._toArray(that.itemMap));
                }, 300);
            }
        },

        _toArray: function(obj) {
            return Object.keys(obj).map(function(key) {
                return obj[key]
            });
        },

        _computeFilteredItemsLength: function (filteredItems) {
            return filteredItems ? filteredItems.length : 0;
        },

        setShowNoData: function (items, filteredItems) {
            if (this.items && !this.items.length)
                this.set('showNoData', true);
            else {
                if (this.filteredItems && !this.filteredItems.length)
                    this.set('showNoData', true);
                else
                    this.set('showNoData', false);
            }
        },

        _onWheel: function (e) {
            var t = this.querySelector('vaadin-grid-table');
            if (t && t._scrollBottom / t._scrollHeight > 0.75 && !this.finished) {
                var pageno = this.$.grid._getPageForIndex(this.count);
                console.log('request page', pageno);
                this.$.grid._loadPage(pageno);
            }
        },

        windowResize: function () {
            if (this.resizable) {
                this.debounce('windowResize', function () {
                    var top = this.getBoundingClientRect().top;
                    var newHeight,
                        itemsHeight = (this.$.grid.items && this.$.grid.items.length || 0) * 64,
                        isSmallScreen = window.innerWidth <= 768,
                        outerScroller = this.$.grid.$.scroller.$.outerscroller,
                        hasVerticalScroll = outerScroller.scrollWidth > outerScroller.clientWidth,
                        heightOffset = 42;
                    if (hasVerticalScroll) {
                        heightOffset += 16;
                    }
                    if (this.querySelector('h2[slot="header"]'))
                        newHeight = Math.min(window.innerHeight - top - 80, itemsHeight +
                            heightOffset);
                    else
                        newHeight = Math.min(window.innerHeight - top - 24, itemsHeight +
                            heightOffset);
                    if (this.$.grid.$.items.scrollWidth > itemsHeight && this.$.grid.$.items.scrollHeight <=
                        this.scrollHeight)
                        newHeight += 16;
                    this.style.height = newHeight + "px";
                }, 100);
            }
        },

        columnWidth: function (column, frozen) {
            var w;
            try {
                w = localStorage.getItem('mist-list#' + this.id + '/col/' + column + '/width');
            } catch (e) {
                console.warn(e);
            }
            if (w) {
                return w;
            } else if (frozen) {
                return this.frozenWidth + 'px';
            } else {
                return '120px'
            }
        },

        saveColumnWidth: function (e) {
            var column = e.target.childNodes[1].childNodes[1].id.split('sorter-column-')[1];
            localStorage.setItem('mist-list#' + this.id + '/col/' + column + '/width', e.target.style.width);
        },

        _filterItems: function (items, length, filter, filterMethod) {
            console.warn('filterItems', filter);
            if (this.items) {
                this.debounce('_filterListItems', function (items) {
                    console.warn('filterItems exec', filter);
                    this.set('filteredItems', this.items.filter(this.applyFilter.bind(this)));
                    this.fire('mist-list-filtered-items-length-changed', {
                        length: this.filteredItems.length
                    });
                    this.$.grid.set('items', this.filteredItems);

                    if (this.selectedItems.length) {
                        this.debounce('cleanupSelectedItems', function () {
                            var newSelectedItems = [],
                                _this = this;
                            for (var i = 0; i < _this.selectedItems.length; i++) {
                                var j = this.filteredItems.findIndex(
                                    function (item) {
                                        return item.id === _this.selectedItems[i].id
                                    }
                                );
                                if (j > -1)
                                    newSelectedItems.push(this.filteredItems[j]);
                            }
                            this.set('selectedItems', newSelectedItems);
                            this.async(function () {
                                this.fire('resize');
                            }, 100);
                        }, 200);
                    } else {
                        this.debounce('iron-resize', function () {
                            this.$.grid.fire('iron-resize');
                        }, 100);
                    }
                }, 500);
            }
        },

        applyFilter: function (item, index) {
            var q = this.combinedFilter ? this.combinedFilter.slice(0) : '',
                queryTerms;
            if (this.filterMethod.apply) {
                var response = this.filterMethod.apply(item,q);
                // response can be false or a query stripped of owner filter
                if (response === false) {
                    return false;
                } else {
                    q = this.filterMethod.apply(item,q);
                }
            }
            if (q.length) {
                // TODO: properly filter parenthesis
                queryTerms = q.replace(/\(/g, '').replace(/\)/g, '').replace(/ AND /g,
                    ' ').replace(/ OR /g, ' ').split(' ');

                // Check if all terms exist in item
                for (var i = 0; i < queryTerms.length; i++) {
                    if (queryTerms[i] && queryTerms[i].length)
                        if (queryTerms[i].indexOf(':') > -1) {
                            var kv = queryTerms[i].split(':'),
                                k = kv[0],
                                v = kv[1];
                            if (item[k] != v) {
                                // check also rendered values
                                if (this.columns.indexOf(k) > -1 && this._getBody(k, item).toLowerCase()
                                    .indexOf(v.toLowerCase()) > -1) {
                                    return true;
                                }
                                return false;
                            }
                        } else if (this._getRenderedItem(item).toLowerCase().indexOf(queryTerms[i].toLowerCase()) <
                        0) {
                        return false;
                    }
                }
            }
            return true;
        },

        _getRenderedItem: function (item) {
            var renderedFields = '';
            if (this.renderers && this.columns) {
                for (var i = 0; i < this.columns.length; i++) {
                    renderedFields += ' ' + this._getBody(this.columns[i], item);
                }
            }
            return renderedFields + ' ' + JSON.stringify(item);
        },

        _itemsUpdated: function (items) {
            if (this.items) {
                this.set('received', this.items.length);
                this.set('count', this.items.length);
            }
            if (this.items && this.items.length) {
                // update column map using response.items values
                for (var i = 0; i < this.items.length; i++) {
                    var item = this.items[i];
                    if (this.rest)
                        this.itemMap[item[this.primaryFieldName]] = item;
                    var keys = Object.keys(item);
                    for (var k = 0; k < keys.length; k++) {
                        this.colmap[keys[k]] = true;
                    }
                }
                var cols = Object.keys(this.colmap);
                // Add the visible columns if any that are not an item property
                if (this.visible && this.visible.length) {
                    for (var j = 0; j < this.visible.length; j++) {
                        if (cols.indexOf(this.visible[j]) == -1) {
                            cols.push(this.visible[j]);
                        }
                    }
                }
                // Compute columns list from colmap, removing frozen columns
                this.frozen.forEach(function (f) {
                    if (cols.indexOf(f) > -1)
                        cols.splice(cols.indexOf(f), 1);
                });
                this.set('columns', cols);
            }
        },

        _activeItemChanged: function (e) {
            console.log('_activeItemChanged',e);
            var grid = e.target;
            this._clickedItem = grid && grid.activeItem ? grid.activeItem : this._clickedItem;

            // we should either redirect to the proper route path, or expand the item
            if (this._clickedItem) {
                if (this.route != undefined)
                    this.set('route.path', this._clickedItem[this.primaryFieldName]);
                else if (this.expands)
                    if (grid.expandedItems.indexOf(this._clickedItem) > -1) {
                        grid.collapseItem(this._clickedItem);
                    } else {
                        grid.expandItem(this._clickedItem);
                    }
            }
        },

        _itemKeys: function (item) {
            if (!item) return [];
            return Object.keys(item)
        },

        _getTitle: function (column) {
            if (this.renderers[column] && this.renderers[column].title) {
                if (typeof this.renderers[column].title == 'function')
                    return this.renderers[column].title();
                else
                    return this.renderers[column].title;
            }
            return column;
        },

        _getBody: function (column, item) {
            if (item) {
                if (this.renderers[column])
                    return this.renderers[column].body(item[column], item);
                if (typeof (item[column]) == 'undefined') return '';
                if (typeof (item[column]) == 'string')
                    return item[column];

                var ret = JSON.stringify(item[column]);
                if (['undefined', '[]', '{}'].indexOf(ret) == -1)
                    return ret;
            }
            return '';
        },

        _getRawBody: function (column, item) {
            if (item)
                return JSON.stringify(item[column]);
            return '';
        },

        _isColumnVisible: function (column) {
            return this.visible && this.visible.indexOf(column) > -1;
        },

        _isCsvVisible: function (column) {
            return this.CSVvisible && this.CSVvisible.indexOf(column) > -1;
        },

        _getSelectedColumnsIndexArray: function (visible) {
            if (!this.visible) return [];
            var ret = [];
            for (var i = 0; i < this.visible.length; i++)
                ret.push(this.columns.indexOf(this.visible[i]));
            // console.log('_getSelectedColumnsIndexArray returning', ret);
            return ret;
        },

        _hasReceivedAll: function (received, count) {
            return this.count && this.received == this.count
        },

        _checkboxChanged: function (e) {
            // console.log('_checkboxChanged', e.model.column, e.target.active, e.model.item);
            if (e.target.active && this.visible.indexOf(e.model.column) == -1) {
                this.push('visible', e.model.column);
            } else if (!e.target.active && this.visible.indexOf(e.model.column) > -1) {
                this.splice('visible', this.visible.indexOf(e.model.column), 1);
            }
            localStorage.setItem('mist-list#' + this.id, JSON.stringify(this.visible));
        },

        _CSVcheckboxChanged: function (e) {
            if (e.target.active && this.CSVvisible.indexOf(e.model.column) == -1) {
                this.push('CSVvisible', e.model.column);
            } else if (!e.target.active && this.CSVvisible.indexOf(e.model.column) > -1) {
                this.splice('CSVvisible', this.CSVvisible.indexOf(e.model.column), 1);
            }
        },

        _toggleDrawer: function () {
            if (document.querySelector('app-drawer'))
                document.querySelector('app-drawer').toggle();
        },

        _isGridBody: function (detail) {
            console.warn('_isGridBody', detail);
            //return detail.sourceEvent.target.parentElement.parentElement.tagName === 'TD';
        },

        toggleSelectAll: function (selectAll) {
            if (selectAll && this.count != this.selectedItems.length) {
                this.set('selectedItems', this.filteredItems);
            } else if (!selectAll && this.count == this.selectedItems.length){
                this.set('selectedItems', []);
            }
        },

        selectedItemsChanged: function (itemslength) {
            if (this.count && this.count == itemslength && !this.selectAll) {
                this.set('selectAll', true);
            } else if (this.count && this.count != itemslength && this.selectAll) {
                this.set('selectAll', false);
            }
        },

        _getComparisonFunction: function (column) {
            return this.renderers[column] && this.renderers[column].cmp;
        },

        _computeIconStyle: function (expanded) {
            // TODO: animate icon
            if (!expanded) return "transform: rotate(270deg);"
        },

        _computeIndicatorStyle: function (item, indicator) {
            if (!indicator)
                return '';
            return this._getBody('indicator', item)
        },

        _computeIcon: function (item, icon) {
            if (!icon || !item || !this.renderers['icon'])
                return '';
            return this.renderers['icon'].body(item, item) || '';
        },

        _computeId: function (item) {
            if (!item)
                return '';
            return item[this.primaryFieldName];
        },

        eventReceived: function (item) {
            if (!this.streaming)
                return;
            console.debug('eventReceived', item, this.applyFilter(item.detail));
            if (this.applyFilter(item.detail))
                this.async(function () {
                    if (this.$.grid && this.$.grid.get('_cache.0') != undefined) {
                        this.$.grid.unshift('_cache.0', item.detail);
                        this.$.grid.fire('iron-resize');
                    }
                });
        },

        _computeFilter: function (baseFilter, userFilter) {
            if (!baseFilter)
                return userFilter;
            if (!userFilter)
                return baseFilter;
            return '(' + baseFilter + ') AND (' + userFilter + ')';
        },

        _computeMenuButtonStyle: function (selectable, expands, columnMenu, selectedItemsLength, count) {
            if (!columnMenu || selectedItemsLength || !count)
                return 'display: none';
            var left = 0;
            if (selectable) {
                left += 52;
                if (expands)
                    left += 12;
            }
            return 'left:' + left + 'px;'
        },

        _or: function (a, b) {
            return a || b
        },

        _preventDefault: function (e) {
            e.preventDefault();
        },

        _startEditingFilter: function (e) {
            if (this.searchable) {
                this.editingFilter = true;
                this.$.searchInput.focus();
            }
        },

        _stopEditingFilter: function (e) {
            this.async(function () {
                if (!e.detail.value && this._filterIsAPresetFilter()) {
                    this.set('editingFilter',false);
                }
            }, 100);
        },

        _filterIsAPresetFilter: function() {
            return !this.userFilter.trim() || this.combinedPresetFilters.map(function(m){return m.filter;}).indexOf(this.userFilter.trim()) > -1;
        },

        _forceStopEditingFilter: function(f) {
            this.set('editingFilter',false);
        },

        _keyDown: function (e) {
            if (e.keyCode == 27) {
                this._clearFilter(e);
            }
        },

        _clearFilter: function (e) {
            if (this.autoHide) {
                this.autoHide = false;
                this.async(function(){
                    this.autoHide = true;
                }.bind(this),1000);
            }
            this.userFilter = '';
            this.selectedPresetFilter = '';
            this.editingFilter = false;
        },

        _baseFilterUpdated: function () {
            // Reset the user defined filter every time the base filter gets updated
            if (this.userFilter) {
                this.set('userFilter', '');
            }
            this.editingFilter = false;
        },

        _computeHidden: function (autoHide, count, editingFilter) {
            return autoHide && !count && !editingFilter;
        },

        _computeMenuCellWidth: function (expands) {
            return expands && '46px' || '24px';
        },

        _computeUseDataProvider: function (apiurl) {
            return this.apiurl && this.apiurl.length && this.rest;
        },

        _openDialogSelectColumns: function (e) {
            this.querySelector('#columnsDialog').open();
        },

        _openDialogExportCsv: function (e) {
            this.querySelector('#csvDialog').open();
        },

        _exportCsv: function (e) {
            this.$.getCsv.headers["Csrf-Token"] = CSRF_TOKEN;
            this.$.getCsv.headers["Accept"] = "text/csv";
            this.$.getCsv.url = this.apiurl + "?columns=" + this.frozen.concat(this.CSVvisible).join();
            this.$.getCsv.generateRequest();
        },

        _csvRequest: function (e) {
            this.fire('export-list-csv', {
                message: 'Requesting CSV.'
            });
        },

        _computeCSVname: function (str) {
            var ch = str.split('/');
            return ch[ch.length - 1] + '-list.csv';
        },

        _csvResponse: function (e) {
            this.set('CSVresponse', e.detail.xhr.response);
            this._downloadFile();
        },

        _downloadFile: function (name, data) {
            this.querySelector("#downloadCSV").click();
            //clear
            this.set('CSVresponse', '');
        },

        _csvError: function (e) {
            console.log('_csvError', e);
            this.fire('export-list-csv', {
                message: 'Error in CSV.' + e.detail.error
            });
        },

        _visibleChanged: function (visible) {
            // console.log('visible changed', this.visible);
            this.set('CSVvisible', this.CSVvisible || visible);
        },

        _sorterChanged: function (event) {
            this.debounce('_updateSorters', function() {
                console.debug('_updateSorters');
                this.set('sortOrder', this.$.grid._sorters.map(x => [x.path, x.direction]));
                try {
                    localStorage.setItem('mist-list#' + this.id + '/sorters', JSON.stringify(this.sortOrder));
                } catch (e) {console.warn(e);}
            }, 500);
        },

        _getDirection: function (column) {
            if (this.sorters) {
                for (var i=0; i < this.sorters.length; i++) {
                    if (this.sorters[i][0] == column)
                        return this.sorters[i][1];
                }
            }
        },
        _enterFullscreen: function (e) {
            this.set('fullscreen',true);
        },
        _exitFullscreen: function (e) {
            this.set('fullscreen',false);
        },
        addFilter: function(filter) {
            this.push('userSavedFilters', filter);
            localStorage.setItem('mist-list#' + this.id + '/userSavedFilters', JSON.stringify(this.userSavedFilters));
            this.fire('filter-change');
            this._forceStopEditingFilter();
        },
        deleteFilter: function(index) {
            console.log('_deleteFilter IN', index);
            this.splice('userSavedFilters', index, 1);
            localStorage.setItem('mist-list#' + this.id + '/userSavedFilters', JSON.stringify(this.userSavedFilters));
            this.fire('filter-change');
        },
        useFilter: function(filter) {
            if (typeof filter == "object" && filter.filter) {
                this.set('userFilter', filter.filter);
            } 
            if (typeof filter == "string") {
                this.set('userFilter', filter);
            }
            this.set('selectedPresetFilter', this.userFilter);
        },
        _displayName: function(name,selectedPresetFilter,userFilter) {
            if (!this.selectedPresetFilter || !this.selectedPresetFilter.length) {
                return this.name && this.name.length ? this.name : 'All';
            } else {
                var that = this,
                    filter = this.userSavedFilters.find(function(f){
                        return that.selectedPresetFilter == f.filter;
                    });
                return filter ? filter.name : '';
            }
        },
        _selectedPresetFilterChanged: function(filters) {
            this.set('userFilter', this.selectedPresetFilter);
        },
        _openDialogSaveFilter: function(e) {
            this.set('filterName', this.userFilter.slice(0));
            this.querySelector('#filterName').focus();
            this.querySelector('#filterDialog').open();
        },
        _saveFilter: function(e) {
            if (this.presetFilters.map(function(m){return m.filter;}).indexOf(this.userFilter.trim()) == -1) {
                var newfilter  = {
                    name: this.filterName,
                    filter: this.userFilter,
                    default: false
                };
                this.addFilter(newfilter);
            }
            this.useFilter(newfilter);
            this.querySelector('#filterName').blur();
            this.querySelector('#filterDialog').close();
            this.set('filterName','');
        },
        _deletePresetFilter: function(e) {
            e.stopPropagation();
            this.deleteFilter(this.userSavedFilters.indexOf(e.model.item))
            if (this.selectedPresetFilter == e.model.item.filter) {
                this.useFilter('');
            }
            if (this.userFilter.indexOf(e.model.item.filter) > -1) {
                this.set('userFilter', this.userFilter.replace(e.model.item.filter, ""));
            }
        },
        _userFilterChanged: function (userFilter) {
            if (userFilter != undefined) {
                var trimmed = userFilter.trim();
                if (this.editingFilter) {
                    this._updateSelectedFilter(userFilter);
                }
                localStorage.setItem('mist-list#' + this.id + '/userFilter', this.userFilter);
            }
        },
        _updateSelectedFilter: function(userFilter) {
            var that = this,
                filter = this.userSavedFilters.find(function(f){
                    return userFilter == f.filter;
                });
            if (filter) {
                this.set('selectedPresetFilter', this.userFilter);
            }
        },
        _computeShowSaveSearch: function(userFilter, presetFiltersLength) {
            return this.editingFilter && this.userFilter.length && !this._filterIsAPresetFilter();
        },
        _computeCombinedPresetFilters: function(presetFilters, userSavedFilters) {
            var pf = this.presetFilters || [] ,
                usf = this.userSavedFilters || [];
            return pf.concat(usf);
        },
        hotkeys: function(e) {
            // ENTER
            if (e.keyCode === 13 && this.$.searchInput.focused) {
                this._updateSelectedFilter(this.userFilter);
                // stop editing only if 
                if (this.userFilter == this.selectedPresetFilter) {
                    this._forceStopEditingFilter();
                }
            }
            // ENTER
            if (e.keyCode === 13 && this.$.filterDialog.opened) {
                this._saveFilter();
            }
        }
    });
</script>